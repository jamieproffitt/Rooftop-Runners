go.property("angular_velocity", 3)
FRICTION = 1
JUMP_SPEED = 5000
GRAVITY = 10

function init(self)
	self.correction = vmath.vector3()
	self.lastRotation = -1
	self.rotationCount = 0
	self.velocity = vmath.vector3(0, 0, 0)
	self.canJump = true
	self.jumping = false
	self.jumpCount = 0
	self.safePosition = go.get_position()
	self.follow = true
	msg.post("#", "acquire_input_focus") 
end

function final(self)
	-- Add finalization code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

function handleRot2(self, dt)
	rotation = go.get_rotation()
	if self.rotating == hash("left") then
		rotation = rotation * vmath.quat_rotation_z(self.angular_velocity * 1 * dt)
	elseif self.rotating == hash("right") then
		rotation = rotation * vmath.quat_rotation_z(self.angular_velocity * -1 * dt)
	end
	return rotation
end

function handleRot(self, rotation, dt)
	if self.rotating == hash("left") then
		if self.rotationCount < 25 then
			self.rotationCount = self.rotationCount + 1
			rotation = rotation * vmath.quat_rotation_z(self.angular_velocity * 1 * dt)
		elseif self.onGround == false then
			self.rotationCount = 0
			self.lastRotation = hash("none")
		end
	elseif self.rotating == hash("right") then
		if self.rotationCount < 25 then
			self.rotationCount = self.rotationCount + 1
			rotation = rotation * vmath.quat_rotation_z(self.angular_velocity * -1 * dt)
		elseif self.onGround == false then
			rotation = rotation * vmath.quat_rotation_z(self.angular_velocity * -1 * dt)
		end
	elseif self.lastRotation == hash("left") then
		print("attempt fix1")
		if rotation.z > 0 and self.onGround == true then
			print("fix rotate1")
			rotation = rotation * vmath.quat_rotation_z(self.angular_velocity * -1 * dt)
		elseif self.onGround == true then
			self.lastRotation = hash("none")
			self.rotationCount = 0
		else
			self.lastRotation = hash("none")
			self.rotationCount = 0
		end
	elseif self.lastRotation == hash("right") then
		if rotation.z < 0 and self.onGround == true then
			rotation = rotation * vmath.quat_rotation_z(self.angular_velocity * 1 * dt)
			print("fix rotate")
		elseif self.onGround == true then
			self.lastRotation = hash("none")
			self.rotationCount = 0
		end
	end
	return rotation
end

local function clamp(type, v, min, max)
	if type == y then
		if v < min then return min 
		elseif v > max then return max 
		else return v end
	else
		if v < 0 then return 0 end
	end
end

function checkFall(self)
	local pos = go.get_position()
	if pos.y < -100 then
		go.set_position(self.safePosition)
	end
end

function handlejump(self, dt)
	if self.jumping == true then
		print("Jump")
		self.velocity.y = self.velocity.y + 500 * dt
		self.jumping = false
		self.canJump = false
	end
	local quat_to_north = vmath.quat_rotation_z(math.rad(0)) -- the rotation around z to rotate to due north
	print(quat_to_north)
	local parent_quat = go.get_world_rotation()-- the parent's world rotation
	local diff_quat = vmath.quat_from_to(quat_to_north, parent_quat.z)
	local angle_to_north = vmath.quat_to_angle(diff_quat).z
	print(angle_to_north)
end
function update(self, dt)
	self.velocity.y = self.velocity.y - GRAVITY * dt
	--self.velocity.y = clamp(y, self.velocity.y, -500, 500)
	self.velocity.x = self.velocity.x - FRICTION * dt
	self.velocity.x = clamp(x, self.velocity.x, 0, 0)
	handlejump(self, dt)
	checkFall(self)
	rotation = handleRot2(self, dt)
	local pos = go.get_position()
	pos = pos + self.velocity 
	go.set_position(pos)
	go.set_rotation(rotation)
	self.correction = vmath.vector3()
end

function fixed_update(self, dt)
	-- Add update code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

function on_message(self, message_id, message, sender)
	if message_id == hash("contact_point_response") then
		if message.other_group == hash("default") then
			self.canJump = true
			self.onGround = true
		else
			self.onGround = false
		end
		if message.distance > 0 then
			local proj = vmath.project(self.correction, message.normal * message.distance)
			if proj < 1 then
				local comp = (message.distance - message.distance * proj) * message.normal
				go.set_position(go.get_position() + comp)
				self.correction = self.correction + comp
				self.velocity.y = 0
			end
		end
	end
end

function on_input(self, action_id, action)
	if action_id == hash("player1_left") then
		if action.pressed then
			msg.post("#sprite", "play_animation", {id = hash("player_left")})
			self.rotating = hash("left")
		elseif action.released then
			self.rotating = nil
			self.lastRotation = hash("left")
		end
	end
	if action_id == hash("player1_right") then
		if action.pressed then
			msg.post("#sprite", "play_animation", {id = hash("player_right")})
			self.rotating = hash("right")
		elseif action.released then
			self.rotating = nil
			self.lastRotation = hash("right")
		end
	end
	if action_id == hash("player1_jump") then
		if action.pressed and self.canJump == true then
			self.jumping = true
			self.onGround = false
		end
	end
	if self.follow then
		msg.post("camera", "follow")
	else
		msg.post("camera", "unfollow")
	end
end

function on_reload(self)
	-- Add reload-handling code here
	-- Learn more: https://defold.com/manuals/hot-reload/
	-- Remove this function if not needed
end
